# Waybar + Nix კონფიგურაციის წესი — მკაფიო და არაბუნდოვანი განმარტება

ეს ჰენდაუტი **განახლებულია და გასწორებულია** იმის მიხედვით, რაც რეალურად გამოიკვეთა შენს მუშა კონფიგზე მუშაობისას.

აქ **არ არის ზოგადი საუბარი**. აქ არის **ზუსტი წესი** — სად, როდის და რატომ იწერება `custom/power` ან `custom.power`, ისე რომ:

- კონფიგი იყოს მუშა
- ღილაკები არ გაქრეს
- Home Manager-ის მაგია არ აგერიოს Waybar-ის JSON ლოგიკაში

---

## 0. მთავარი პრობლემა, რაც უნდა გაქრეს

ადრე ჰენდაუტში ბუნდოვნად ჩანდა თითქოს:

> `custom.power` ყოველთვის სწორი ფორმაა

ეს **არ არის სრული სიმართლე**.

სიმართლე ასეთია:

> **ფორმა დამოკიდებულია იმაზე, სად წერ კონფიგს**.

ამ ჰენდაუტის მიზანი სწორედ ეს განსხვავება არის.

---

## 1. Waybar კონფიგის ორი სტილი (ეს არის საფუძველი)

Waybar-ს Home Manager-ით კონფიგურაციისას რეალურად არსებობს **ორი განსხვავებული სტილი**:

### სტილი A — "სუფთა Waybar JSON" (შენი ამჟამინდელი სტილი)

- ყველაფერი იწერება `settings.mainBar`-ში
- custom მოდულები იწერება **სტრინგ-გასაღებით**
- Home Manager აქ პრაქტიკულად არაფერს გარდაქმნის

შენი კონფიგი სწორედ ამ სტილს იყენებს.

### სტილი B — "Home Manager abstraction"

- custom მოდულები იწერება `settings`-ის ზედა დონეზე
- გამოიყენება `custom.power` ფორმა
- Home Manager აკეთებს გარდაქმნას → `custom/power`

ეს სტილი შენ **არ იყენებ**.

---

## 2. სტილი A — ზუსტი წესი (შენი მუშა კონფიგის წესი)

თუ კონფიგი წერია ასე:

```nix
programs.waybar.settings = {
  mainBar = {
    modules-right = [ "custom/power" ];

    "custom/power" = {
      exec = "~/.config/waybar/scripts/power-icon.sh";
      return-type = "json";
    };
  };
};
```

მაშინ წესები ასეთია:

### ✔ უნდა გამოიყენო
- `"custom/power" = { ... };`
- `modules-right = [ "custom/power" ];`

### ❌ არ უნდა გამოიყენო
- `custom.power = { ... };`

რატომ?

რადგან `mainBar`-ის შიგნით Home Manager **აღარ აკეთებს mapping-ს** `custom.power → custom/power`.

Waybar ელოდება **ზუსტ JSON გასაღებს**.

---

## 3. სტილი B — როდის არის სწორი `custom.power`

`custom.power` **სწორია მხოლოდ მაშინ**, როცა ის წერია აქ:

```nix
programs.waybar.settings = {
  custom.power = {
    exec = "...";
  };

  mainBar = {
    modules-right = [ "custom/power" ];
  };
};
```

აქ Home Manager:

- ხედავს `custom.power`
- გარდაქმნის მას Waybar-ისთვის → `custom/power`

მაგრამ ეს მუშაობს **მხოლოდ settings-ის ზედა დონეზე**.

---

## 4. რატომ გაქრა ღილაკი შენს შემთხვევაში

შენ დაწერე:

```nix
mainBar = {
  modules-right = [ "custom/power" ];

  custom.power = { ... };
};
```

ეს არის **არასწორი მიქსი ორი სტილის**.

შედეგი:

- Waybar ეძებს `custom/power`
- კონფიგში რეალურად არსებობს `custom.power`
- mapping არ ხდება
- მოდული უბრალოდ **არ იხატება**

---

## 5. ოქროს წესი (ერთი აბზაცი, არანაირი ბუნდოვნება)

თუ წერ:

- custom მოდულებს `mainBar`-ის შიგნით → **ყოველთვის** გამოიყენე `"custom/..."`
- custom მოდულებს `settings`-ის ზედა დონეზე → შეგიძლია გამოიყენო `custom.xxx`

**ორი სტილის შერევა აკრძალულია.**

---

## 6. პრაქტიკული რეკომენდაცია შენთვის

შენი კონფიგის გათვალისწინებით:

✔ დატოვე **ყველა custom მოდული ერთ სტილში**
✔ გამოიყენე `"custom/power"`, `"custom/kbd"`, `"custom/separator"`
✔ არ გამოიყენო `custom.power` `mainBar`-ის შიგნით

ეს არის:

- უფრო მკაფიო
- უფრო ნაკლებად მაგიური
- უფრო ადვილად გასაგები მომავალში

---

## 7. საბოლოო შეჯამება

- პრობლემა არ იყო Nix-ში
- პრობლემა არ იყო Waybar-ში
- პრობლემა იყო **ჰენდაუტში არასაკმარისად მკაფიო წესში**

ეს ვერსია უკვე აღწერს **რეალურ წესს**, არა თეორიულს.

თუ ამ წესს დაიცავ, მსგავსი გაუგებრობა აღარ განმეორდება.


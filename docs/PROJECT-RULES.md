# GPT Project Rules — NixOS Flake Dev Machine

ეს დოკუმენტი განსაზღვრავს **წესებს, საზღვრებს და პრინციპებს**, რომლითაც მიმდინარეობს
NixOS Flake Dev Machine პროექტზე მუშაობა.

ეს წესები **მაღალ პრიორიტეტს** ფლობს ყველა ტექნიკურ გადაწყვეტილებაზე.

---

## 1. მხარდაჭერილი პლატფორმა

- მხარდაჭერილია **მხოლოდ NixOS 25.11 და უფრო ახალი**
- ძველი ვერსიები:
  - არ განიხილება
  - არ იხსენიება
  - არ მოყვანილია მაგალითებად

თუ საკითხი ეხება ძველ ვერსიას — პასუხი არ გაიცემა.

---

## 2. Flake — სავალდებულო საფუძველი

- ყველა კონფიგურაცია არის **flake-based**
- channel-based ან legacy მიდგომები აკრძალულია
- `flake.lock`:
  - ყოველთვის არსებობს
  - არასოდეს იშლება ხელით
  - ყოველთვის კომიტშია

Flake გამოიყენება როგორც **კოორდინატორი**, არა როგორც ლოგიკის მატარებელი.

---

## 3. Host-based არქიტექტურა

- სისტემა იყოფა host-ებზე
- თითო host არის:
  - სრული სისტემა
  - დამოუკიდებელი არქიტექტურული ერთეული

მიმდინარე მთავარი host:
```text
laptop
````

ახალი host ემატება **კოპირებით + გააზრებული ადაპტაციით**, არა მიბმით.

---

## 4. System vs User — მკაცრი გამიჯვნა

ეს არის **ფუნდამენტური წესი**.

### System Layer (NixOS)

შეიცავს:

* hardware
* kernel
* services
* desktop architecture (WM / DM)
* networking
* security

### User Layer (Home Manager)

შეიცავს:

* shell
* editor
* CLI tools
* workflow
* user-level services

აკრძალულია:

* system ლოგიკის user layer-ში გადატანა
* desktop-ის მართვა Home Manager-ით

---

## 5. Home Manager — როლი და საზღვრები

Home Manager გამოიყენება როგორც:

> **Minimal User Environment Manager**

ის **არ არის**:

* system manager
* desktop owner
* hardware abstraction layer

ეს შეზღუდვა არის **შეგნებული არქიტექტურული გადაწყვეტილება**.

---

## 6. ფაილების სტრუქტურის წესები

* `flake.nix`:

  * მხოლოდ wiring
  * არ შეიცავს ლოგიკას

* `hosts/<host>/default.nix`:

  * მხოლოდ შემკრები
  * არ იტვირთება ზედმეტი ლოგიკა

* `hardware.nix`:

  * მხოლოდ hardware
  * არაფერი სხვა

* `users.nix`:

  * users + HM მიბმა
  * არ შეიცავს system პარამეტრებს

* `home/*.nix`:

  * მხოლოდ user გარემო

---

## 7. Workflow — ცვლილებების წესი

სავალდებულო ციკლი:

```text
edit → git commit → nixos-rebuild → verify
```

აკრძალულია:

* rebuild დაუკომიტებელი ცვლილებებით
* flake-ის გარეშე rebuild

---

## 8. Rollback და უსაფრთხოება

* ყველა ცვლილება უნდა იყოს rollback-able
* boot menu ითვლება სარეზერვო მექანიზმად
* generations პერიოდულად იწმინდება, გააზრებულად

სისტემა, რომლის rollback ვერ კეთდება — ითვლება დაზიანებულად.

---

## 9. Pitfalls — სავალდებულო დაფიქსირება

ყველა დოკუმენტაციაში და ახსნაში:

* უნდა იყოს მითითებული ტიპური შეცდომები
* უნდა აიხსნას რატომ არის ეს შეცდომა
* უნდა იყოს ნაჩვენები სწორი გზა

არ დაიშვება „უბრალოდ ასე გააკეთე“.

---

## 10. სასწავლო პრინციპები

ეს პროექტი:

* არ მალავს სირთულეს
* არ ამარტივებს ხელოვნურად
* ავითარებს სისტემურ აზროვნებას

სწავლის თანმიმდევრობა ყოველთვის არის:

1. რა არის სისტემა
2. როგორ არის აწყობილი
3. როგორ იგება
4. როგორ მოწმდება
5. მხოლოდ მერე — ექსპერიმენტები

---

## 11. გადაწყვეტილებების ტონი

ყველა ახსნა უნდა იყოს:

* პირდაპირი
* ტექნიკურად ზუსტი
* ტრადიციული Unix/Nix აზროვნებით
* მიკიბ-მოკიბვის გარეშე

აკრძალულია:

* „ჯადოსნური“ ახსნა
* კონტექსტის დამალვა
* ზედმეტი ლირიკა

---

## 12. ამ წესების სტატუსი

ეს დოკუმენტი არის:

* სავალდებულო
* გადამწყვეტი
* ყველა სხვა გადაწყვეტილებაზე მაღლა მდგომი

თუ რაიმე გადაწყვეტილება ეწინააღმდეგება ამ წესებს —
**წესი იმარჯვებს**.

---

**ეს პროექტი არ არის ექსპერიმენტი.
ეს არის გააზრებული სისტემა.**


ნებისმიერი პრობლემის განხილვა იწყება ფაზის იდენტიფიკაციით
(evaluation / build / activation / boot)

nixos-rebuild-ის ლოგი ითვლება პირველწყაროდ
სხვა ლოგები იკითხება მხოლოდ ამის შემდეგ.

Evaluation trace ყოველთვის იკითხება ქვემოდან ზემოთ.

/nix/store-ზე მითითებული trace არასდროს არის გამოსასწორებელი ადგილი.

Evaluation შეცდომა არასდროს ნიშნავს სისტემის დაზიანებას.

Build შეცდომა იკვლევა მხოლოდ nix log-ით.

Activation პრობლემები იკვლევა მხოლოდ systemctl / journalctl-ით.

Boot პრობლემები იკვლევა წინა generation-ის ლოგებით.

ერთი დოკუმენტი ემსახურება ერთ პრობლემურ ფაზას.

ბრძანება დოკუმენტაციაში იწერება მხოლოდ გამოყენების კონტექსტთან ერთად.

რეალური შეცდომის მაგალითის გარეშე წესი არ ითვლება დასრულებულად.

Home Manager არასდროს გამოიყენება system troubleshooting-ისთვის.

Rebuild არასდროს სრულდება დაუკომიტებელი ცვლილებებით.

ფაილის ცვლილება დასაშვებია მხოლოდ მას შემდეგ, რაც trace მიუთითებს ზუსტ წყაროს.

ჩეთი, რომელმაც გამოავლინა პრაქტიკული ცოდნა, უნდა გადაიქცეს დოკუმენტად.
